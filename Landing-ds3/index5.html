<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fountain Soundscape - Providence Athenaeum</title>
    <style>
        @font-face {
            font-family: 'Monument Grotesk Mono';
            src: url("fonts/ABCMonumentGroteskMono-Regular-Trial.otf") format('opentype');
            font-weight: 400;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none;
        }

        :root {
            --white: #ffffff;
            --black: #000000;
            --gray: #808080;
        }

        body {
            font-family: 'Monument Grotesk Mono', 'Courier New', monospace;
            background: var(--black);
            overflow: hidden;
        }

        /* Custom Cursor */
        .cursor {
            width: 40px;
            height: 40px;
            border: 1px solid var(--white);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            transition: transform 0.2s ease;
            mix-blend-mode: difference;
        }

        .cursor.hover {
            transform: scale(1.5);
        }

        /* Noise Effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            z-index: 1;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        #waterBackground {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            filter: grayscale(100%) contrast(1.1);
            background-image: url("img/img4.jpg");
        }

        /* Navigation */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 2rem 3rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 100;
            mix-blend-mode: difference;
        }

        .nav-left, .nav-right {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .nav-item {
            font-size: 0.75rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.8;
            color: var(--white);
        }

        .menu-toggle {
            cursor: pointer;
            font-size: 0.75rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            background: none;
            border: none;
            color: var(--white);
            padding: 0;
            transition: opacity 0.3s ease;
            font-family: 'Monument Grotesk Mono', monospace;
        }

        .menu-toggle:hover {
            opacity: 0.5;
        }

        /* p5.js Canvas for liquid blobs */
        #gobletCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 40;
            pointer-events: none;
        }

        /* Audio Player */
        .soundcloud-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 180px;
            background: var(--black);
            backdrop-filter: blur(10px);
            z-index: 100;
            display: flex;
            flex-direction: column;
            border-top: 1px solid var(--white);
        }

        .player-controls {
            padding: 2rem 3rem;
            display: flex;
            align-items: center;
            gap: 2rem;
        }

        .play-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: transparent;
            border: 1px solid var(--white);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .play-button:hover {
            background: var(--white);
            transform: scale(1.05);
        }

        .play-button:hover .play-icon {
            border-color: transparent transparent transparent var(--black);
        }

        .play-button.active {
            background: var(--white);
        }

        .play-button.active .play-icon {
            border-color: transparent transparent transparent var(--black);
        }

        .play-icon {
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 10px 0 10px 16px;
            border-color: transparent transparent transparent var(--white);
            margin-left: 3px;
        }

        .play-button.active .play-icon {
            border-style: double;
            border-width: 0 0 0 16px;
            height: 20px;
            margin-left: 0;
        }

        .player-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .track-title {
            color: var(--white);
            font-size: 0.75rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .track-artist {
            color: var(--gray);
            font-size: 0.65rem;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .waveform-container {
            flex: 1;
            height: 60px;
            position: relative;
            cursor: pointer;
        }

        .waveform {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .waveform-bar {
            flex: 1;
            background: rgba(255, 255, 255, 0.2);
            height: 30%;
            border-radius: 0;
            transition: all 0.1s ease;
        }

        .waveform-bar.active {
            background: var(--white);
            height: 100%;
        }

        /* Droplet intensity control */
        .droplet-control-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 380px;
        }

        .control-label {
            color: var(--white);
            font-size: 0.65rem;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 1.2rem;
        }

        .intensity-marker {
            color: var(--gray);
            font-size: 0.65rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            min-width: 55px;
            text-align: center;
        }

        #gobletSlider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 2px;
            background: var(--white);
            outline: none;
            border-radius: 0;
            border: none;
        }

        #gobletSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--white);
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.3s ease;
            border: 1px solid var(--black);
        }

        #gobletSlider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        #gobletSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--white);
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.3s ease;
            border: 1px solid var(--black);
        }

        #gobletSlider::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        .intensity-display {
            display: flex;
            align-items: center;
            gap: 0.8rem;
        }

        .intensity-value {
            color: var(--white);
            font-size: 0.65rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            min-width: 70px;
        }

        /* Audio level meter */
        .level-meters {
            display: flex;
            gap: 1rem;
            align-items: center;
            padding: 0 3rem 1rem 3rem;
        }

        .level-meter {
            flex: 1;
            max-width: 400px;
        }

        .level-label {
            color: var(--gray);
            font-size: 0.6rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }

        .level-bar-container {
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 0;
            overflow: hidden;
        }

        .level-bar {
            height: 100%;
            background: var(--white);
            width: 0%;
            transition: width 0.05s ease;
        }

        .frequency-levels {
            display: flex;
            gap: 0.5rem;
        }

        .freq-meter {
            flex: 1;
        }

        .freq-label {
            color: var(--gray);
            font-size: 0.6rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 0.3rem;
            text-align: center;
        }

        .freq-bar-container {
            height: 2px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 0;
            overflow: hidden;
        }

        .freq-bar {
            height: 100%;
            width: 0%;
            transition: width 0.05s ease;
        }

        .freq-bar.bass,
        .freq-bar.mid,
        .freq-bar.high {
            background: var(--white);
        }

        @media (max-width: 768px) {
            .soundcloud-player {
                height: 220px;
            }

            .player-controls {
                padding: 1.5rem;
                flex-wrap: wrap;
                gap: 1rem;
            }

            .level-meters {
                padding: 0 1.5rem 1rem 1.5rem;
            }

            .droplet-control-section {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="cursor"></div>

    <!-- Water Background -->
    <div id="waterBackground"></div>

    <!-- p5.js Canvas for liquid blobs -->
    <div id="gobletCanvas"></div>

    <!-- Navigation -->
    <nav>
        <div class="nav-left">
            <div class="nav-item">[ Fountain ]</div>
            <div class="nav-item">Live Audio</div>
        </div>
        <div class="nav-right">
            <button class="menu-toggle" onclick="window.location.href='index.html'">[ Return ]</button>
            <div class="nav-item">2025</div>
        </div>
    </nav>

    <!-- Audio Player -->
    <div class="soundcloud-player">
        <div class="player-controls">
            <button class="play-button" id="playButton">
                <div class="play-icon"></div>
            </button>

            <div class="player-info">
                <div class="track-title">[ Athenaeum Fountain ]</div>
                <div class="track-artist">Live Microphone Input</div>
            </div>

            <div class="waveform-container" id="waveform">
                <div class="waveform" id="waveformBars"></div>
            </div>

            <div class="droplet-control-section" style="margin-left: 2rem;">
                <div class="control-label">[ Goblet Morphing ]</div>
                <div class="slider-container">
                    <span class="intensity-marker">Simple</span>
                    <input type="range" id="gobletSlider" min="0" max="100" value="0" step="1">
                    <span class="intensity-marker">Complex</span>
                </div>
                <div class="intensity-display">
                    <div class="intensity-value" id="gobletValue">Off</div>
                </div>
            </div>
        </div>

        <div class="level-meters">
            <div class="level-meter">
                <div class="level-label">Audio Level</div>
                <div class="level-bar-container">
                    <div class="level-bar" id="levelBar"></div>
                </div>
            </div>

            <div class="frequency-levels">
                <div class="freq-meter">
                    <div class="freq-label">Bass</div>
                    <div class="freq-bar-container">
                        <div class="freq-bar bass" id="bassBar"></div>
                    </div>
                </div>
                <div class="freq-meter">
                    <div class="freq-label">Mid</div>
                    <div class="freq-bar-container">
                        <div class="freq-bar mid" id="midBar"></div>
                    </div>
                </div>
                <div class="freq-meter">
                    <div class="freq-label">High</div>
                    <div class="freq-bar-container">
                        <div class="freq-bar high" id="highBar"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jquery.ripples@0.6.3/dist/jquery.ripples.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    
    <script>
        // Custom cursor
        const cursor = document.querySelector('.cursor');
        let mouseX = 0, mouseY = 0;
        let cursorX = 0, cursorY = 0;

        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        function animateCursor() {
            cursorX += (mouseX - cursorX) * 0.1;
            cursorY += (mouseY - cursorY) * 0.1;
            cursor.style.left = cursorX + 'px';
            cursor.style.top = cursorY + 'px';
            requestAnimationFrame(animateCursor);
        }
        animateCursor();

        document.addEventListener('mouseover', (e) => {
            if (e.target.closest('button, .waveform-container')) {
                cursor.classList.add('hover');
            }
        });
        
        document.addEventListener('mouseout', (e) => {
            if (e.target.closest('button, .waveform-container')) {
                cursor.classList.remove('hover');
            }
        });

        let isListening = false;
        let audioContext, analyser, source;
        let gobletMorphing = 0;
        let p5Instance = null;
        let droplets = [];

        // p5.js sketch
        const liquidSketch = (p) => {
            let phase = 0;
            let playerHeight = 180;
            const GRID_SIZE = 6;
            const THRESHOLD = 1.0;
            let grid = [];
            let gridWidth, gridHeight;
            let flowField = [];
            
            function initGrid() {
                gridWidth = Math.ceil(p.width / GRID_SIZE);
                gridHeight = Math.ceil(p.height / GRID_SIZE);
                grid = [];
                flowField = [];
                for (let i = 0; i < gridWidth; i++) {
                    grid[i] = [];
                    flowField[i] = [];
                    for (let j = 0; j < gridHeight; j++) {
                        grid[i][j] = 0;
                        flowField[i][j] = {vx: 0, vy: 0};
                    }
                }
            }
            
            function lerp2d(p1, p2, v1, v2) {
                if (Math.abs(v1 - v2) < 0.001) return p1;
                let t = (THRESHOLD - v2) / (v1 - v2);
                t = Math.max(0, Math.min(1, t));
                return {
                    x: p2.x + (p1.x - p2.x) * t,
                    y: p2.y + (p1.y - p2.y) * t
                };
            }
            
            p.setup = () => {
                const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('gobletCanvas');
                p.noFill();
                p.stroke(255);
                p.strokeWeight(2);
                initGrid();
            };
            
            p.draw = () => {
                p.clear();
                
                if (gobletMorphing === 0) {
                    droplets = [];
                    return;
                }
                
                const spawnRate = p.map(gobletMorphing, 0, 100, 0.05, 0.15);
                if (p.random() < spawnRate && droplets.length < 120) {
                    droplets.push({
                        x: p.random(p.width * 0.25, p.width * 0.75),
                        y: p.random(30, 80),
                        vx: p.random(-3, 3),
                        vy: p.random(0, 2),
                        radius: p.random(18, 45),
                        mass: p.random(1, 2),
                        settled: false,
                        target: null,
                        energy: 1.0
                    });
                }
                
                if (p.mouseIsPressed || (p.touches && p.touches.length > 0)) {
                    let mx = p.mouseX;
                    let my = p.mouseY;
                    if (p.touches && p.touches.length > 0) {
                        mx = p.touches[0].x;
                        my = p.touches[0].y;
                    }
                    
                    for (let i = 0; i < droplets.length; i++) {
                        setTimeout(() => {
                            if (droplets[i]) {
                                droplets[i].target = {x: mx, y: my};
                            }
                        }, i * 30);
                    }
                }
                
                let bottomY = p.height - playerHeight;
                for (let i = droplets.length - 1; i >= 0; i--) {
                    let drop = droplets[i];
                    
                    if (!drop.settled) {
                        if (drop.target) {
                            let dx = drop.target.x - drop.x;
                            let dy = drop.target.y - drop.y;
                            drop.vx += dx * 0.0008;
                            drop.vy += dy * 0.0008;
                            
                            if (Math.abs(dx) < 50 && Math.abs(dy) < 50) {
                                drop.target = null;
                            }
                        } else {
                            drop.vy += 0.3;
                        }
                        
                        drop.vx *= 0.98;
                        drop.vy *= 0.98;
                        drop.x += drop.vx;
                        drop.y += drop.vy;
                        
                        for (let other of droplets) {
                            if (other !== drop && other.settled) {
                                let dx = drop.x - other.x;
                                let dy = drop.y - other.y;
                                let dist = p.sqrt(dx * dx + dy * dy);
                                let minDist = drop.radius + other.radius;
                                
                                if (dist < minDist * 0.8) {
                                    let angle = p.atan2(dy, dx);
                                    drop.x = other.x + p.cos(angle) * minDist;
                                    drop.y = other.y + p.sin(angle) * minDist;
                                    drop.settled = true;
                                    drop.vy = 0;
                                    drop.vx *= 0.3;
                                    drop.target = null;
                                    break;
                                }
                            }
                        }
                        
                        if (drop.y + drop.radius >= bottomY) {
                            drop.y = bottomY - drop.radius;
                            drop.settled = true;
                            drop.vy = 0;
                            drop.vx *= 0.5;
                            drop.target = null;
                        }
                        
                        if (drop.x - drop.radius < 0) {
                            drop.x = drop.radius;
                            drop.vx *= -0.6;
                        }
                        if (drop.x + drop.radius > p.width) {
                            drop.x = p.width - drop.radius;
                            drop.vx *= -0.6;
                        }
                    } else {
                        for (let j = i - 1; j >= 0; j--) {
                            let other = droplets[j];
                            if (other.settled) {
                                let dx = other.x - drop.x;
                                let dy = other.y - drop.y;
                                let dist = p.sqrt(dx * dx + dy * dy);
                                
                                if (dist < (drop.radius + other.radius) * 0.65) {
                                    let totalMass = drop.mass + other.mass;
                                    drop.x = (drop.x * drop.mass + other.x * other.mass) / totalMass;
                                    drop.y = (drop.y * drop.mass + other.y * other.mass) / totalMass;
                                    drop.radius = p.sqrt(drop.radius * drop.radius + other.radius * other.radius);
                                    drop.mass = totalMass;
                                    droplets.splice(j, 1);
                                    if (j < i) i--;
                                    break;
                                } else if (dist < (drop.radius + other.radius) * 1.3) {
                                    drop.x += dx * 0.015;
                                    drop.y += dy * 0.015;
                                }
                            }
                        }
                    }
                }
                
                for (let i = 0; i < gridWidth; i++) {
                    for (let j = 0; j < gridHeight; j++) {
                        let x = i * GRID_SIZE;
                        let y = j * GRID_SIZE;
                        let value = 0;
                        let flowX = 0, flowY = 0;
                        
                        for (let drop of droplets) {
                            let dx = drop.x - x;
                            let dy = drop.y - y;
                            let distSq = dx * dx + dy * dy;
                            if (distSq > 0.1) {
                                let influence = (drop.radius * drop.radius * 1.3) / distSq;
                                value += influence;
                                
                                if (distSq < drop.radius * drop.radius * 4) {
                                    flowX += drop.vx * influence;
                                    flowY += drop.vy * influence;
                                }
                            }
                        }
                        
                        grid[i][j] = value;
                        flowField[i][j] = {vx: flowX, vy: flowY};
                    }
                }
                
                p.strokeCap(p.ROUND);
                p.strokeJoin(p.ROUND);
                
                for (let i = 0; i < gridWidth - 1; i++) {
                    for (let j = 0; j < gridHeight - 1; j++) {
                        let x = i * GRID_SIZE;
                        let y = j * GRID_SIZE;
                        
                        let a = grid[i][j] >= THRESHOLD;
                        let b = grid[i][j + 1] >= THRESHOLD;
                        let c = grid[i + 1][j + 1] >= THRESHOLD;
                        let d = grid[i + 1][j] >= THRESHOLD;
                        
                        let state = (a ? 8 : 0) | (b ? 4 : 0) | (c ? 2 : 0) | (d ? 1 : 0);
                        
                        if (state === 0 || state === 15) continue;
                        
                        let va = grid[i][j];
                        let vb = grid[i][j + 1];
                        let vc = grid[i + 1][j + 1];
                        let vd = grid[i + 1][j];
                        
                        let corners = [
                            {x: x, y: y},
                            {x: x, y: y + GRID_SIZE},
                            {x: x + GRID_SIZE, y: y + GRID_SIZE},
                            {x: x + GRID_SIZE, y: y}
                        ];
                        
                        let p1, p2;
                        
                        switch(state) {
                            case 1: case 14:
                                p1 = lerp2d(corners[3], corners[2], vd, vc);
                                p2 = lerp2d(corners[3], corners[0], vd, va);
                                break;
                            case 2: case 13:
                                p1 = lerp2d(corners[2], corners[1], vc, vb);
                                p2 = lerp2d(corners[2], corners[3], vc, vd);
                                break;
                            case 3: case 12:
                                p1 = lerp2d(corners[3], corners[0], vd, va);
                                p2 = lerp2d(corners[2], corners[1], vc, vb);
                                break;
                            case 4: case 11:
                                p1 = lerp2d(corners[1], corners[0], vb, va);
                                p2 = lerp2d(corners[1], corners[2], vb, vc);
                                break;
                            case 6: case 9:
                                p1 = lerp2d(corners[0], corners[1], va, vb);
                                p2 = lerp2d(corners[3], corners[2], vd, vc);
                                break;
                            case 7: case 8:
                                p1 = lerp2d(corners[0], corners[3], va, vd);
                                p2 = lerp2d(corners[0], corners[1], va, vb);
                                break;
                        }
                        
                        if (p1 && p2) {
                            let avgDensity = (va + vb + vc + vd) / 4;
                            let weight = p.map(avgDensity, THRESHOLD, THRESHOLD * 3, 1.5, 4, true);
                            p.strokeWeight(weight);
                            p.stroke(255, 255, 255, 240);
                            p.line(p1.x, p1.y, p2.x, p2.y);
                        }
                    }
                }
                
                p.noStroke();
                for (let i = 1; i < gridWidth - 1; i += 2) {
                    for (let j = 1; j < gridHeight - 1; j += 2) {
                        let value = grid[i][j];
                        if (value > THRESHOLD * 1.3) {
                            let x = i * GRID_SIZE + p.random(-2, 2);
                            let y = j * GRID_SIZE + p.random(-2, 2);
                            
                            let dotSize = p.map(value, THRESHOLD * 1.3, THRESHOLD * 4, 2, 6, true);
                            let alpha = p.map(value, THRESHOLD * 1.3, THRESHOLD * 4, 100, 200, true);
                            
                            p.fill(255, 255, 255, alpha);
                            p.circle(x, y, dotSize);
                        }
                    }
                }
                
                p.stroke(255, 255, 255);
                for (let i = 2; i < gridWidth - 2; i += 3) {
                    for (let j = 2; j < gridHeight - 2; j += 3) {
                        let value = grid[i][j];
                        if (value > THRESHOLD * 1.5) {
                            let x = i * GRID_SIZE;
                            let y = j * GRID_SIZE;
                            
                            let flow = flowField[i][j];
                            let flowMag = p.sqrt(flow.vx * flow.vx + flow.vy * flow.vy);
                            
                            if (flowMag > 0.005) {
                                let alpha = p.map(value, THRESHOLD * 1.5, THRESHOLD * 4, 120,